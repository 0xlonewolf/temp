$scriptContent = @'
# Morohub Active Directory Posture Assessment & Remediation Tool
# Description: Comprehensive AD security assessment and attack path detection tool
# Requirements: PowerShell 5.1+, ActiveDirectory, GroupPolicy modules

<#
.SYNOPSIS
    Morohub Active Directory Posture Assessment & Remediation Tool
    
.DESCRIPTION
    Comprehensive Active Directory security assessment tool that detects attack paths,
    persistence mechanisms, and security misconfigurations. Provides detailed reporting
    and risk assessment with CIS compliance mapping.
    
.PARAMETER QuickScan
    Run quick security scan (basic checks only)
    
.PARAMETER FullAssessment
    Run comprehensive security assessment (all checks)
    
.PARAMETER CheckTrusts
    Include trust relationship analysis
    
.PARAMETER CheckPasswords
    Include password policy and account analysis
    
.PARAMETER CheckPrivilegedGroups
    Include privileged group membership analysis
    
.PARAMETER CheckGPOs
    Include Group Policy Object analysis
    
.PARAMETER CheckCertificates
    Include certificate template analysis
    
.PARAMETER ParallelExecution
    Enable parallel execution for performance
    
.PARAMETER OutputFormat
    Output format: CSV, HTML, Both, or BloodHound
    
.PARAMETER VerboseLogging
    Enable verbose logging
    
.PARAMETER OutputDirectory
    Custom output directory path (default: Morohub-ADPA-Output)
    
.EXAMPLE
    .\Morohub-ADPA.ps1 -QuickScan
    
.EXAMPLE
    .\Morohub-ADPA.ps1 -FullAssessment -OutputFormat Both
    
.EXAMPLE
    .\Morohub-ADPA.ps1 -CheckTrusts -CheckPasswords -OutputFormat HTML
    
.EXAMPLE
    .\Morohub-ADPA.ps1 -FullAssessment -OutputDirectory "C:\Security\AD-Assessment-Results"
    
.NOTES
    This tool requires:
    - PowerShell 5.1 or higher
    - Active Directory module
    - Group Policy module
    - Domain user with appropriate permissions
    
.LINK
    https://morohub.com/security-tools
#>

[CmdletBinding()]
param(
    [switch]$QuickScan,
    [switch]$FullAssessment,
    [switch]$CheckTrusts,
    [switch]$CheckPasswords,
    [switch]$CheckPrivilegedGroups,
    [switch]$CheckGPOs,
    [switch]$CheckCertificates,
    [switch]$ParallelExecution,
    [ValidateSet("CSV", "HTML", "Both", "BloodHound")]
    [string]$OutputFormat = "Both",
    [switch]$VerboseLogging,
    [string]$OutputDirectory = "Morohub-ADPA-Output"
)

# Set error handling
$OldErrorState = $ErrorActionPreference
$ErrorActionPreference = "Continue"

# =============================================================================
# COMPLEX INITIALIZATION LOGGING & ENVIRONMENT VALIDATION
# =============================================================================

# Initialize comprehensive logging system
$script:InitializationLog = @{
    StartTime = Get-Date
    PowerShellVersion = $PSVersionTable.PSVersion.ToString()
    ExecutionPolicy = Get-ExecutionPolicy
    CurrentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
    ComputerName = $env:COMPUTERNAME
    DomainName = $env:USERDOMAIN
    OSVersion = (Get-WmiObject -Class Win32_OperatingSystem).Caption
    Architecture = $env:PROCESSOR_ARCHITECTURE
    WorkingDirectory = Get-Location
    ScriptPath = $MyInvocation.MyCommand.Path
    ScriptVersion = "1.0.0"
    BuildDate = "202412010000"
}

# Enhanced initialization logging function
function Write-InitializationLog {
    [CmdletBinding()]
    param(
        [string]$Component,
        [string]$Status,
        [string]$Details = "",
        [string]$Level = "Info"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $logEntry = "[$timestamp] [INIT] [$Component] $Status"
    if ($Details) {
        $logEntry += " - $Details"
    }
    
    # Console output with initialization-specific formatting
    $color = switch ($Level) {
        "Info" { "White" }
        "Warning" { "Yellow" }
        "Error" { "Red" }
        "Success" { "Green" }
        "Security" { "Magenta" }
        default { "Cyan" }
    }
    
    Write-Host $logEntry -ForegroundColor $color
    
    # Store in initialization log for later output
    if (-not $script:InitializationLog.ContainsKey("LogEntries")) {
        $script:InitializationLog.LogEntries = @()
    }
    $script:InitializationLog.LogEntries += @{
        Timestamp = $timestamp
        Component = $Component
        Status = $Status
        Details = $Details
        Level = $Level
    }
}

# Environment validation function
function Test-EnvironmentCompatibility {
    [CmdletBinding()]
    param()
    
    Write-InitializationLog -Component "Environment" -Status "Starting compatibility validation" -Level "Info"
    
    $compatibilityResults = @{
        PowerShellVersion = $false
        ExecutionPolicy = $false
        AdminPrivileges = $false
        ModulesAvailable = @()
        Warnings = @()
        Errors = @()
    }
    
    # PowerShell version check
    if ($PSVersionTable.PSVersion.Major -ge 5) {
        $compatibilityResults.PowerShellVersion = $true
        Write-InitializationLog -Component "PowerShell" -Status "Version compatible" -Details "v$($PSVersionTable.PSVersion)" -Level "Success"
    } else {
        Write-InitializationLog -Component "PowerShell" -Status "Version incompatible" -Details "v$($PSVersionTable.PSVersion) - Required: 5.1+" -Level "Error"
        $compatibilityResults.Errors += "PowerShell version $($PSVersionTable.PSVersion) is below required minimum 5.1"
    }
    
    # Execution policy check
    $execPolicy = Get-ExecutionPolicy
    if ($execPolicy -in @("RemoteSigned", "Unrestricted", "Bypass")) {
        $compatibilityResults.ExecutionPolicy = $true
        Write-InitializationLog -Component "ExecutionPolicy" -Status "Policy acceptable" -Details $execPolicy -Level "Success"
    } else {
        Write-InitializationLog -Component "ExecutionPolicy" -Status "Policy restrictive" -Details $execPolicy -Level "Warning"
        $compatibilityResults.Warnings += "Execution policy $execPolicy may restrict script execution"
    }
    
    # Admin privileges check
    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object System.Security.Principal.WindowsPrincipal($currentUser)
    if ($principal.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)) {
        $compatibilityResults.AdminPrivileges = $true
        Write-InitializationLog -Component "Privileges" -Status "Administrator access confirmed" -Level "Success"
    } else {
        Write-InitializationLog -Component "Privileges" -Status "Limited privileges detected" -Details "Some operations may fail" -Level "Warning"
        $compatibilityResults.Warnings += "Script running without administrator privileges"
    }
    
    # Module availability check
    $requiredModules = @("ActiveDirectory", "GroupPolicy")
    foreach ($module in $requiredModules) {
        if (Get-Module -ListAvailable -Name $module) {
            $compatibilityResults.ModulesAvailable += $module
            Write-InitializationLog -Component "Module" -Status "Available" -Details $module -Level "Success"
        } else {
            Write-InitializationLog -Component "Module" -Status "Missing" -Details $module -Level "Warning"
            $compatibilityResults.Warnings += "Required module $module not available"
        }
    }
    
    # Network connectivity check
    try {
        $domain = Get-ADDomain -ErrorAction Stop
        Write-InitializationLog -Component "Network" -Status "Domain connectivity confirmed" -Details $domain.DNSRoot -Level "Success"
    } catch {
        Write-InitializationLog -Component "Network" -Status "Domain connectivity failed" -Details $_.Exception.Message -Level "Warning"
        $compatibilityResults.Warnings += "Unable to connect to Active Directory domain"
    }
    
    # Performance baseline
    $script:InitializationLog.PerformanceBaseline = @{
        MemoryUsage = [System.GC]::GetTotalMemory($false)
        ProcessMemory = (Get-Process -Id $PID).WorkingSet64
        CPUUsage = (Get-Counter "\Processor(_Total)\% Processor Time").CounterSamples[0].CookedValue
    }
    
    Write-InitializationLog -Component "Environment" -Status "Compatibility validation completed" -Level "Info"
    
    return $compatibilityResults
}

# Initialize comprehensive logging
Write-InitializationLog -Component "System" -Status "Starting Morohub ADPA initialization" -Level "Info"
Write-InitializationLog -Component "System" -Status "Script version" -Details $script:InitializationLog.ScriptVersion -Level "Info"
Write-InitializationLog -Component "System" -Status "Build date" -Details $script:InitializationLog.BuildDate -Level "Info"
Write-InitializationLog -Component "System" -Status "PowerShell version" -Details $script:InitializationLog.PowerShellVersion -Level "Info"
Write-InitializationLog -Component "System" -Status "Execution policy" -Details $script:InitializationLog.ExecutionPolicy -Level "Info"
Write-InitializationLog -Component "System" -Status "Current user" -Details $script:InitializationLog.CurrentUser -Level "Info"
Write-InitializationLog -Component "System" -Status "Computer name" -Details $script:InitializationLog.ComputerName -Level "Info"
Write-InitializationLog -Component "System" -Status "OS version" -Details $script:InitializationLog.OSVersion -Level "Info"
Write-InitializationLog -Component "System" -Status "Architecture" -Details $script:InitializationLog.Architecture -Level "Info"
Write-InitializationLog -Component "System" -Status "Working directory" -Details $script:InitializationLog.WorkingDirectory -Level "Info"
Write-InitializationLog -Component "System" -Status "Script path" -Details $script:InitializationLog.ScriptPath -Level "Info"

# Run environment compatibility check
$script:EnvironmentCompatibility = Test-EnvironmentCompatibility

# Log compatibility results summary
$successCount = ($script:EnvironmentCompatibility.PowerShellVersion -eq $true) + 
                ($script:EnvironmentCompatibility.ExecutionPolicy -eq $true) + 
                ($script:EnvironmentCompatibility.AdminPrivileges -eq $true)
$totalChecks = 3

Write-InitializationLog -Component "Summary" -Status "Environment compatibility" -Details "$successCount/$totalChecks checks passed" -Level $(if ($successCount -eq $totalChecks) { "Success" } else { "Warning" })

if ($script:EnvironmentCompatibility.Warnings.Count -gt 0) {
    Write-InitializationLog -Component "Summary" -Status "Warnings detected" -Details "$($script:EnvironmentCompatibility.Warnings.Count) warnings" -Level "Warning"
}

if ($script:EnvironmentCompatibility.Errors.Count -gt 0) {
    Write-InitializationLog -Component "Summary" -Status "Errors detected" -Details "$($script:EnvironmentCompatibility.Errors.Count) errors" -Level "Error"
}

Write-InitializationLog -Component "System" -Status "Initialization logging system ready" -Level "Success"

# Initialize variables
$script:OutputDir = $OutputDirectory
$script:LogFile = "Morohub-ADPA.log"
$script:SecurityLogFile = "Morohub-ADPA-Security.log"
$script:ExecutionMode = "Standard"
$script:ChecksToRun = @()
$script:DomainInfo = $null
$script:ForestInfo = $null
$script:SecurityFindings = @{
    CompletedChecks = 0
    FailedChecks = 0
    SkippedChecks = 0
    HighRisk = @()
    MediumRisk = @()
    LowRisk = @()
}
$script:PerformanceMetrics = @{
    StartTime = Get-Date
    CheckTimes = @{}
}

# Determine execution mode
if ($QuickScan) {
    $script:ExecutionMode = "QuickScan"
} elseif ($FullAssessment) {
    $script:ExecutionMode = "FullAssessment"
} else {
    $script:ExecutionMode = "Standard"
}

# Create output directory
if (-not (Test-Path $script:OutputDir)) {
    New-Item -Path $script:OutputDir -ItemType Directory -Force | Out-Null
}

# Enhanced logging function
function Write-MorohubLog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Info", "Warning", "Error", "Security")]
        [string]$Level = "Info"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # Console output with colors
    switch ($Level) {
        "Info" { Write-Host $logEntry -ForegroundColor White }
        "Warning" { Write-Host $logEntry -ForegroundColor Yellow }
        "Error" { Write-Host $logEntry -ForegroundColor Red }
        "Security" { Write-Host $logEntry -ForegroundColor Magenta }
    }
    
    # File logging
    Add-Content -Path (Join-Path $script:OutputDir $script:LogFile) -Value $logEntry -Encoding UTF8
    
    # Security-specific logging
    if ($Level -eq "Security") {
        Add-Content -Path (Join-Path $script:OutputDir $script:SecurityLogFile) -Value $logEntry -Encoding UTF8
    }
}

# Progress tracking function
function Log-MorohubProgress {
    [CmdletBinding()]
    param(
        [string]$CheckID,
        [string]$CheckName,
        [string]$Status,
        [string]$Details = ""
    )
    
    $progressMessage = "$CheckID - $CheckName - $Status"
    if ($Details) {
        $progressMessage += " - $Details"
    }
    
    Write-MorohubLog -Message $progressMessage -Level "Info"
    
    # Update metrics
    switch ($Status) {
        "Completed" { $script:SecurityFindings.CompletedChecks++ }
        "Failed" { $script:SecurityFindings.FailedChecks++ }
        "Skipped" { $script:SecurityFindings.SkippedChecks++ }
    }
}

# Enhanced group membership enumeration
function Get-GroupMembers {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$GroupName
    )
    
    try {
        $group = Get-ADGroup -Identity $GroupName -Properties Members
        $members = @()
        
        foreach ($member in $group.Members) {
            try {
                $memberObj = Get-ADObject -Identity $member -Properties objectClass, sAMAccountName, displayName
                
                if ($memberObj.objectClass -eq "user") {
                    $members += [PSCustomObject]@{
                        Type = "User"
                        SamAccountName = $memberObj.sAMAccountName
                        DisplayName = $memberObj.displayName
                        DistinguishedName = $memberObj.DistinguishedName
                    }
                } elseif ($memberObj.objectClass -eq "group") {
                    $members += [PSCustomObject]@{
                        Type = "Group"
                        SamAccountName = $memberObj.sAMAccountName
                        DisplayName = $memberObj.displayName
                        DistinguishedName = $memberObj.DistinguishedName
                    }
                    
                    # Recursively get nested group members
                    $nestedMembers = Get-GroupMembers -GroupName $memberObj.sAMAccountName
                    $members += $nestedMembers
                }
            } catch {
                Write-MorohubLog -Message "Error processing group member $member : $($_.Exception.Message)" -Level "Warning"
            }
        }
        
        return $members
    } catch {
        Write-MorohubLog -Message "Error getting group members for $GroupName : $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# DCSync rights detection
function Get-DCSyncRights {
    [CmdletBinding()]
    param()
    
    try {
        Write-MorohubLog -Message "Checking for DCSync rights..." -Level "Security"
        
        $dcSyncRights = @()
        $domain = Get-ADDomain
        $domainSID = $domain.DomainSID
        
        # Check for users with DCSync rights (trusted for delegation)
        $dcSyncUsers = Get-ADUser -Filter * -Properties sAMAccountName, displayName, userAccountControl | Where-Object { ($_.userAccountControl -band 524288) -eq 524288 }
        
        foreach ($user in $dcSyncUsers) {
            $dcSyncRights += [PSCustomObject]@{
                ObjectType = "User"
                SamAccountName = $user.sAMAccountName
                DisplayName = $user.displayName
                RiskLevel = "Critical"
                Description = "User has DCSync rights (Replicating Directory Changes)"
                Recommendation = "Review and remove if not required for legitimate replication"
            }
        }
        
        # Check for groups with DCSync rights (Global Security Groups)
        $dcSyncGroups = Get-ADGroup -Filter * -Properties sAMAccountName, displayName, groupType | Where-Object { ($_.groupType -band 2147483648) -eq 2147483648 }
        
        foreach ($group in $dcSyncGroups) {
            $dcSyncRights += [PSCustomObject]@{
                ObjectType = "Group"
                SamAccountName = $group.sAMAccountName
                DisplayName = $group.displayName
                RiskLevel = "Critical"
                Description = "Group has DCSync rights (Replicating Directory Changes)"
                Recommendation = "Review and remove if not required for legitimate replication"
            }
        }
        
        # Export findings to CSV for analyst review
        if ($dcSyncRights.Count -gt 0) {
            $dcSyncCSVPath = Join-Path $script:OutputDir "S127-DCSync-Rights-Detection.csv"
            $dcSyncRights | Export-Csv -Path $dcSyncCSVPath -NoTypeInformation -Encoding UTF8
            Write-MorohubLog -Message "DCSync findings exported to: $dcSyncCSVPath" -Level "Info"
        }
        
        Write-MorohubLog -Message "DCSync rights check completed. Found $($dcSyncRights.Count) objects with DCSync rights." -Level "Info"
        return $dcSyncRights
        
    } catch {
        Write-MorohubLog -Message "Error checking DCSync rights: $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# Dangerous ACL detection
function Get-DangerousACLs {
    [CmdletBinding()]
    param()
    
    try {
        Write-MorohubLog -Message "Checking for dangerous ACLs..." -Level "Security"
        
        $dangerousACLs = @()
        $domain = Get-ADDomain
        
        # Check for GenericAll permissions on critical objects
        $criticalObjects = @(
            "CN=Domain Controllers,$($domain.DistinguishedName)",
            "CN=Users,$($domain.DistinguishedName)",
            "CN=Computers,$($domain.DistinguishedName)"
        )
        
        foreach ($objectDN in $criticalObjects) {
            try {
                $acl = Get-Acl -Path "AD:$objectDN"
                
                foreach ($access in $acl.Access) {
                    if ($access.AccessControlType -eq "Allow" -and 
                        ($access.ActiveDirectoryRights -like "*GenericAll*" -or
                         $access.ActiveDirectoryRights -like "*WriteDACL*" -or
                         $access.ActiveDirectoryRights -like "*WriteOwner*")) {
                        
                        $dangerousACLs += [PSCustomObject]@{
                            ObjectDN = $objectDN
                            Principal = $access.IdentityReference.Value
                            Rights = $access.ActiveDirectoryRights.ToString()
                            RiskLevel = "High"
                            Description = "Dangerous permissions on critical AD object"
                            Recommendation = "Review and restrict permissions to minimum required"
                        }
                    }
                }
            } catch {
                Write-MorohubLog -Message "Error checking ACLs for $objectDN : $($_.Exception.Message)" -Level "Warning"
            }
        }
        
        # Export findings to CSV for analyst review
        if ($dangerousACLs.Count -gt 0) {
            $dangerousACLsCSVPath = Join-Path $script:OutputDir "S128-Dangerous-ACLs-Detection.csv"
            $dangerousACLs | Export-Csv -Path $dangerousACLsCSVPath -NoTypeInformation -Encoding UTF8
            Write-MorohubLog -Message "Dangerous ACL findings exported to: $dangerousACLsCSVPath" -Level "Info"
        }
        
        Write-MorohubLog -Message "Dangerous ACL check completed. Found $($dangerousACLs.Count) dangerous permissions." -Level "Info"
        return $dangerousACLs
        
    } catch {
        Write-MorohubLog -Message "Error checking dangerous ACLs: $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# Risk scoring function
function Calculate-RiskScore {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$RiskLevel,
        [int]$Severity = 1,
        [int]$Impact = 1
    )
    
    $baseScore = switch ($RiskLevel) {
        "Critical" { 10 }
        "High" { 8 }
        "Medium" { 5 }
        "Low" { 2 }
        default { 1 }
    }
    
    $finalScore = $baseScore * $Severity * $Impact
    return [math]::Min($finalScore, 100) # Cap at 100
}

# Kerberos vulnerabilities detection
function Get-KerberosVulnerabilities {
    [CmdletBinding()]
    param()
    
    try {
        Write-MorohubLog -Message "Checking for Kerberos vulnerabilities..." -Level "Security"
        
        $kerberosVulns = @()
        
        # Check for AS-REP Roasting (users with pre-authentication disabled)
        $asRepUsers = Get-ADUser -Filter * -Properties sAMAccountName, displayName, userAccountControl | Where-Object { ($_.userAccountControl -band 4194304) -eq 4194304 -and ($_.userAccountControl -band 2) -eq 0 }
        
        foreach ($user in $asRepUsers) {
            $kerberosVulns += [PSCustomObject]@{
                VulnerabilityType = "AS-REP Roasting"
                SamAccountName = $user.sAMAccountName
                DisplayName = $user.displayName
                RiskLevel = "High"
                Description = "User has pre-authentication disabled (vulnerable to AS-REP roasting)"
                Recommendation = "Enable pre-authentication for all user accounts"
            }
        }
        
        # Check for unconstrained delegation
        $unconstrainedDelegation = Get-ADComputer -Filter * -Properties sAMAccountName, displayName, userAccountControl | Where-Object { ($_.userAccountControl -band 524288) -eq 524288 }
        
        foreach ($computer in $unconstrainedDelegation) {
            $kerberosVulns += [PSCustomObject]@{
                VulnerabilityType = "Unconstrained Delegation"
                SamAccountName = $computer.sAMAccountName
                DisplayName = $computer.displayName
                RiskLevel = "High"
                Description = "Computer account has unconstrained delegation enabled"
                Recommendation = "Disable unconstrained delegation or configure constrained delegation"
            }
        }
        
        # Check for constrained delegation
        $constrainedDelegation = Get-ADUser -Filter * -Properties sAMAccountName, displayName, "msDS-AllowedToDelegateTo" | Where-Object { $_.'msDS-AllowedToDelegateTo' -ne $null -and $_.'msDS-AllowedToDelegateTo'.Count -gt 0 }
        
        foreach ($user in $constrainedDelegation) {
            $kerberosVulns += [PSCustomObject]@{
                VulnerabilityType = "Constrained Delegation"
                SamAccountName = $user.sAMAccountName
                DisplayName = $user.displayName
                RiskLevel = "Medium"
                Description = "User has constrained delegation configured"
                Recommendation = "Review delegation settings and restrict to minimum required services"
            }
        }
        
        # Export findings to CSV for analyst review
        if ($kerberosVulns.Count -gt 0) {
            $kerberosCSVPath = Join-Path $script:OutputDir "S129-Kerberos-Vulnerabilities.csv"
            $kerberosVulns | Export-Csv -Path $kerberosCSVPath -NoTypeInformation -Encoding UTF8
            Write-MorohubLog -Message "Kerberos vulnerability findings exported to: $kerberosCSVPath" -Level "Info"
        }
        
        Write-MorohubLog -Message "Kerberos vulnerabilities check completed. Found $($kerberosVulns.Count) vulnerabilities." -Level "Info"
        return $kerberosVulns
        
    } catch {
        Write-MorohubLog -Message "Error checking Kerberos vulnerabilities: $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# SID History abuse detection
function Get-SIDHistoryAbuse {
    [CmdletBinding()]
    param()
    
    try {
        Write-MorohubLog -Message "Checking for SID History abuse..." -Level "Security"
        
        $sidHistoryAbuse = @()
        
        # Check for users with SID History
        $usersWithSidHistory = Get-ADUser -Filter * -Properties sAMAccountName, displayName, sIDHistory | Where-Object { $_.sIDHistory -ne $null -and $_.sIDHistory.Count -gt 0 }
        
        foreach ($user in $usersWithSidHistory) {
            $sidHistoryAbuse += [PSCustomObject]@{
                ObjectType = "User"
                SamAccountName = $user.sAMAccountName
                DisplayName = $user.displayName
                SIDHistoryCount = $user.sIDHistory.Count
                RiskLevel = "Medium"
                Description = "User has SID History configured (potential for privilege escalation)"
                Recommendation = "Review SID History and remove if not required for migration"
            }
        }
        
        # Check for groups with SID History
        $groupsWithSidHistory = Get-ADGroup -Filter * -Properties sAMAccountName, displayName, sIDHistory | Where-Object { $_.sIDHistory -ne $null -and $_.sIDHistory.Count -gt 0 }
        
        foreach ($group in $groupsWithSidHistory) {
            $sidHistoryAbuse += [PSCustomObject]@{
                ObjectType = "Group"
                SamAccountName = $group.sAMAccountName
                DisplayName = $group.displayName
                SIDHistoryCount = $group.sIDHistory.Count
                RiskLevel = "Medium"
                Description = "Group has SID History configured (potential for privilege escalation)"
                Recommendation = "Review SID History and remove if not required for migration"
            }
        }
        
        # Export findings to CSV for analyst review
        if ($sidHistoryAbuse.Count -gt 0) {
            $sidHistoryCSVPath = Join-Path $script:OutputDir "S130-SIDHistory-Abuse-Detection.csv"
            $sidHistoryAbuse | Export-Csv -Path $sidHistoryCSVPath -NoTypeInformation -Encoding UTF8
            Write-MorohubLog -Message "SID History abuse findings exported to: $sidHistoryCSVPath" -Level "Info"
        }
        
        Write-MorohubLog -Message "SID History abuse check completed. Found $($sidHistoryAbuse.Count) objects with SID History." -Level "Info"
        return $sidHistoryAbuse
        
    } catch {
        Write-MorohubLog -Message "Error checking SID History abuse: $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# Service account security analysis
function Get-ServiceAccountSecurity {
    [CmdletBinding()]
    param()
    
    try {
        Write-MorohubLog -Message "Analyzing service account security..." -Level "Security"
        
        $serviceAccountIssues = @()
        
        # Check for service accounts with password never expires
        $neverExpireAccounts = Get-ADUser -Filter * -Properties sAMAccountName, displayName, servicePrincipalName, userAccountControl | Where-Object { $_.servicePrincipalName -ne $null -and ($_.userAccountControl -band 65536) -eq 65536 }
        
        foreach ($account in $neverExpireAccounts) {
            $serviceAccountIssues += [PSCustomObject]@{
                IssueType = "Password Never Expires"
                SamAccountName = $account.sAMAccountName
                DisplayName = $account.displayName
                SPNs = ($account.servicePrincipalName -join "; ")
                RiskLevel = "Medium"
                Description = "Service account has password that never expires"
                Recommendation = "Configure password expiration for service accounts"
            }
        }
        
        # Check for service accounts with weak password policies
        $weakPasswordAccounts = Get-ADUser -Filter * -Properties sAMAccountName, displayName, servicePrincipalName, userAccountControl | Where-Object { $_.servicePrincipalName -ne $null -and ($_.userAccountControl -band 32) -eq 0 }
        
        foreach ($account in $weakPasswordAccounts) {
            $serviceAccountIssues += [PSCustomObject]@{
                IssueType = "Weak Password Policy"
                SamAccountName = $account.sAMAccountName
                DisplayName = $account.displayName
                SPNs = ($account.servicePrincipalName -join "; ")
                RiskLevel = "Low"
                Description = "Service account not subject to password complexity requirements"
                Recommendation = "Enable password complexity requirements for service accounts"
            }
        }
        
        # Export findings to CSV for analyst review
        if ($serviceAccountIssues.Count -gt 0) {
            $serviceAccountCSVPath = Join-Path $script:OutputDir "S131-Service-Account-Security.csv"
            $serviceAccountIssues | Export-Csv -Path $serviceAccountCSVPath -NoTypeInformation -Encoding UTF8
            Write-MorohubLog -Message "Service account security findings exported to: $serviceAccountCSVPath" -Level "Info"
        }
        
        Write-MorohubLog -Message "Service account security analysis completed. Found $($serviceAccountIssues.Count) issues." -Level "Info"
        return $serviceAccountIssues
        
    } catch {
        Write-MorohubLog -Message "Error analyzing service account security: $($_.Exception.Message)" -Level "Error"
        return @()
    }
}

# Main script execution
try {
    Write-MorohubLog -Message "Starting Morohub ADPA assessment" -Level "Info"
    
    # Run basic security checks
    $dcSyncResults = Get-DCSyncRights
    $dangerousACLResults = Get-DangerousACLs
    $kerberosResults = Get-KerberosVulnerabilities
    $sidHistoryResults = Get-SIDHistoryAbuse
    $serviceAccountResults = Get-ServiceAccountSecurity
    
    Write-MorohubLog -Message "Assessment completed successfully" -Level "Info"
    
} catch {
    Write-MorohubLog -Message "Critical error during assessment: $($_.Exception.Message)" -Level "Error"
    Write-Host "Critical error occurred during assessment. Check error logs for details." -ForegroundColor Red
}
'@

Set-Content -Path "Morohub-ADPA.ps1" -Value $scriptContent -Encoding UTF8
